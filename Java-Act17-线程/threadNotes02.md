## 9. 线程安全

**（重点）关于多线程并发环境下，数据的安全问题**
线程安全问题的出现主要是因为多线程并发访问共享资源时可能导致的竞态条件（Race Condition）和并发访问冲突。以下是一些常见的原因：

- 竞态条件（Race Condition）：多个线程同时访问共享资源，并且执行的顺序不确定，这可能导致不同的线程在不同的时间点对资源进行操作，从而产生意外的结果。

- 共享资源：线程安全问题通常发生在多个线程共享同一资源（如变量、数据结构、文件、数据库等）的情况下。如果不正确地管理对共享资源的访问，就会发生冲突。

- 并发修改：多个线程同时对数据结构（如集合、数组、映射等）进行修改，如果没有适当的同步控制，可能导致数据结构的损坏或不一致。

- 非原子操作：某些操作不是原子操作，它们在多线程环境中可能被中断，导致部分操作被执行，而不是完整的原子操作。

- 缓存不一致：多个线程使用不同的本地缓存副本，而不是从主内存中获取最新的值。这可能导致不同线程看到不同的数据状态。

- 不同步的访问：没有适当的同步机制（如锁、信号量、条件变量等）来确保多线程之间的协调和互斥，从而导致竞态条件和并发问题。

- 死锁：当多个线程在等待彼此释放锁资源时，可能导致死锁问题，其中所有线程都无法继续执行。

- 饥饿：某些线程可能会永远无法获得所需的资源，因为其他线程总是优先获得资源。

为了解决线程安全问题，开发者需要采用适当的同步机制（如锁、信号量、条件变量等），以确保多线程之间的协调和互斥，防止竞态条件和并发问题的发生。此外，选择合适的数据结构和算法，以及遵循最佳的并发编程实践，也是确保线程安全的关键。

### 9.1 什么时候数据在多线程并发的情况下存在安全问题？

- 有三个条件：
	- 条件一：多线程并发
	- 条件二：有共享数据
	- 条件三：共享数据有修改的行为

### 9.2那么怎么解决这个问题呢？

- 采用“线程同步机制”
  - 即线程排队执行，不能并发。也就是说把多条语句操作共享数据的代码给锁起来，让任意时刻只能有一个线程执行即可
3. 线程同步，涉及以下两个专业术语：
  - 异步编程模型：
    - 线程t1和t2，各自执行各自的，谁也不需要等谁，也就是：多线程并发（效
      率较高）
  - 同步编程模型:
    - 线程t1和t2，在线程t1执行的时候，必须等待t2线程执行结束，或者说线程t2
      执行的时候，必须等待t1线程结束，两个线程之间发生了等待关系。即线程
      排队执行。（效率较低）
```java
 线程同步机制的语法：synchronized (){ 
     					线程同步代码块 }
 \* synchronized ()这个括号里面传递的数据是非常关键的。并且不能为null值
 \* 这个数据必须是多线程共享的数据。才能达到多线程排队。
 那么（）中写的就是你想让哪些线程同步。
 假设有t1,t2,t3,t4，这四个线程，你只希望t1,t2排队，那么你一定要在（）中写一个t1,t2共享的对象。而这个对象对t3,t4来说不是共享的。。。。
```

### 9.3 java 提供了三种同步机制：

1. 同步代码块
2. 同步方法
3. 锁机制【Lock 锁】

#### 9.3.1 同步代码块

`synchronized `关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。

> 语法：
>
> ```java
> synchronized(同步锁){
> 	//同步的代码
> }
> ```
>
> 这里的同步锁：
> 对象的同步锁只是一个概念,可以想象为在任意对象上标记了一个锁，具体的就是上面讲述的。

#### 9.3.2 同步方法

使用 synchronized 修饰的方法,就叫做同步方法,保证A线程执行该方法的时候,其他线程只
能在方法外等着。

> 格式:
>
> ```java
> public synchronized void method(){
> 	//可能产生安全问题的代码
> }
> ```
>
> 那么同步方法中的同步锁是谁呢？
> 		对于“实例方法” ,同步锁就是 this 。
> 		对于 “static 方法” ,我们使用当前方法所在类的字节码对象(类名.class)

#### 9.3.3 Lock 锁

`java.util.concurrent.locks.Lock `机制提供了比 synchronized 代码块和 synchronized方法更广泛的锁定操作,同步代码块/同步方法具有的功能 Lock 都有,除此之外更强大,更体现面向对象。在 JDK 5 引入了 `ReentrantLock `, `ReentrantLock` 重入锁，是实现` Lock 接口`的一个类，也是在实际编程中使用频率很高的一个锁，支持重入性，表示能够对共享资源能够重复加锁，即当前线程获取该锁再次获取不会被阻塞。支持公平锁和非公平锁两种方式。

- 常用方法
  - `public void lock() :`加同步锁。
  - `public void unlock()` :释放同步锁

```java
public class Ticket implements Runnable {
	private int ticket = 100;
	private Lock lock = new ReentrantLock();
	/**
	* 执行卖票操作
	*/
	@Override
	public void run() {
        while (true) {
            // 加同步锁
			lock.lock();
            //chan'sh
			sellTicket();
            // 释放同步锁
			lock.unlock();
		}
	}
	private void sellTicket(){
		if (ticket > 0) {
			try {
				Thread.sleep(100);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			String name = Thread.currentThread().getName();
			System.out.println(name + "正在卖第" + ticket-- + "张票");
		}
	}
}
```
