 **问题描述** 
- 创建对象就会分配内存，不停的创建对象会导致内存溢出。
- 为了防止内存溢出，JVM会对不在使用的对象回收内存。

 **问题：** 
- 请说明堆内存中 新生代、老年代、永久代的分代垃圾回收机制

 **解释：** 
在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：
1. 新生代内存(Young Generation)
2. 老生代(Old Generation 或者 Tenured)
3. 永久代(Permanent Generation)

下图所示的 Eden 区、两个 Survivor 区 S0 和 S1 都属于新生代，中间一层属于老年代，最下面一层属于永久代。
![输入图片说明](../image/%E5%A0%86%E5%86%85%E5%AD%98.png)


![输入图片说明](../image/%E5%86%85%E5%AD%98%E5%9B%BE.png)

 **JDK 8 版本之后 PermGen(永久) 已被 Metaspace(元空间)取代，元空间使用的是
直接内存。** 


![输入图片说明](../image/%E5%86%85%E5%AD%98%E5%9B%BE2.png)

大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象
还存活，则会进入 S0 或者 S1，并且对象的年龄还会加 1(Eden 区->Survivor 区后对
象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到
老年代中，如下图所示。对象晋升到老年代的年龄阈值，可以通过参数 -
XX:MaxTenuringThreshold 来设置。

--------------------------------------------------------

堆这里最容易出现的就是 OutOfMemoryError 错误，并且出现这种错误之后的表现
形式还会有几种，比如：
1. java.lang.OutOfMemoryError: GC Overhead Limit Exceeded ： 当 JVM
花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。
2. java.lang.OutOfMemoryError: Java heap space :假如在创建新的对象时, 堆
内存中的空间不足以存放新创建的对象, 就会引发此错误。(和配置的最大堆内存
有关，且受制于物理内存大小。最大堆内存可通过 -Xmx 参数配置，若没有特别
配置，将会使用默认值
3. ......

JDK7 堆 Heap 分代示例图：
![输入图片说明](../image/%E5%A0%86.png)

 **JDK8 堆 Heap 分代示例图** 
![输入图片说明](../image/%E5%A0%862.png)

 **对象在堆空间中的生命周期（分代年龄的作用）** 

（1）新的对象在Eden区被new出来（大对象例外），一开始的时候两个幸存者区域
和老年代都是空的

![输入图片说明](../image/%E5%A0%86%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F1.png)

（2）对象创建的越来越多，Eden区域逐渐被填满

![输入图片说明](../image/%E5%A0%86%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F2.png)

（3）此时将触发Minor GC，删除没有引用的对象，没有被删除的对象被复制到From幸存区，然后清空Eden区域

![输入图片说明](../image/%E5%A0%86%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F3.png)

（4）对象继续创建，Eden区域又满了，再一次触发Minor GÇ，删除没有引用的对象，留下存在引用的对象，将这些对象和之前复制到From幸存区的对象一起复制到To幸存区，然后清空Eden区和From区。这两步也叫做GC的复制算法

![输入图片说明](../image/%E5%A0%86%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F4.png)

（5）对象继续创建，Eden区域又满了，第三次触发Minor GÇ。与上次不同的是，To区和From区将发生角色转换，然后继续执行第四步

![输入图片说明](../image/%E5%A0%86%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F5.png)

（6）上面的操作其实已经修改了分代年龄，Minor GC每发生一次，没有被删除的对象的分代年龄就会+1，直到达到分代年龄的阀值（默认是15，由JVM参数MaxTenuringThreshold=9决定），这些对象就被移动到老年代。

![输入图片说明](../image/%E5%A0%86%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F6.png)

（7）当老年代的存储快满了时，将触发Major GC，清理老年代没有被引用的对象。
- 老年代使用标记-整理算法
    - 标记-整理（Mark-and-Compact）算法是根据老年代的特点提出的一种标记算
法。
        - 先标记：标记出所有不需要回收的对象
        - 再清理：统一回收掉所有没有被标记的对象
        - 最后移动：让所有存活的对象向一端移动

![输入图片说明](../image/%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.png)

小结：
1. 年轻代是标记复制回收算法
2. 老年代是标记-整理垃圾回收算法