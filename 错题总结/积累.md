## 1.Java 和 C++ 的区别?
我知道很多人没学过 C++，但是面试官就是没事喜欢拿咱们 Java 和 C++ 比呀！没办法！！！就算没学过 C++，也要记下来。
虽然，Java 和 C++ 都是面向对象的语言，都支持封装、继承和多态，但是，它们还是有挺多不相同的地方：
1. Java 不提供指针来直接访问内存，程序内存更加安全
2. Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。
3. Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。
4. C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。
5. ......
## 2.default 这个关键字很特殊

1. 既属于程序控制，也属于类，方法和变量修饰符，还属于访问控制。
- 在程序控制中，当在 switch 中匹配不到任何情况时，可以使用 default 来编写默认匹配的情况。
- 在类，方法和变量修饰符中，从 JDK8 开始引入了默认方法，可以使用 default 关键字来定义一个方法的默认实现。
- 在访问控制中，如果一个方法前没有任何修饰符，则默认会有一个修饰符 default，但是这个修饰符加上了就会报错。

## 3.位移运算符
在 Java 代码里使用` <<`、 `>>` 和`>>>`转换成的指令码运行起来会更高效些。

Java 中有三种移位运算符：
- << :左移运算符，向左移若干位，高位丢弃，低位补零。x << 1,相当于 x 乘以 2(不溢出的情况下)。
- \>> :带符号右移，向右移若干位，高位补符号位，低位丢弃。正数高位补 0,负数高位补 1。x >> 1,相当于 x 除以 2。
- \>>> :无符号右移，忽略符号位，空位都以 0 补齐。

> 由于 double，float 在二进制中的表现比较特殊，因此不能来进行移位操作。移位操作符实际上支持的类型只有int和long，编译器在对short、byte、char类型进行移位前，都会将其转换为int类型再操作。

#### 如果移位的位数超过数值所占有的位数会怎样？
当 int 类型左移/右移位数大于等于 32 位操作时，会先求余（%）后再进行左移/右移操作。也就是说左移/右移 32 位相当于不进行移位操作（32%32=0），左移/右移 42 位相当于左移/右移 10 位（42%32=10）。当 long 类型进行左移/右移操作时，由于 long 对应的二进制是 64 位，因此求余操作的基数也变成了 64。也就是说：x<<42等同于x<<10，x>>42等同于x>>10，x >>>42等同于x >>> 10。
## 4.continue、break 和 return 的区别是什么？
在循环结构中，当循环条件不满足或者循环次数达到要求时，循环会正常结束。但是，有时候可能需要在循环的过程中，当发生了某种条件之后 ，提前终止循环，这就需要用到下面几个关键词：
- continue：指跳出当前的这一次循环，继续下一次循环。
- break：指跳出整个循环体，继续执行循环下面的语句。
- return 用于跳出所在方法，结束该方法的运行。
    - return 一般有两种用法：
    - return;：直接使用 return 结束方法执行，用于没有返回值函数的方法
    - return value;：return 一个特定值，用于有返回值函数的方法
## 5.基本类型和包装类型的区别？
![输入图片说明](../image/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AF%B9%E6%AF%94.png)
- 用途：除了定义一些常量和局部变量之外，我们在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。并且，包装类型可用于泛型，而基本类型不可以。
- 存储方式：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 static 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。
- 占用空间：相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。
- 默认值：成员变量包装类型不赋值就是 null ，而基本类型有默认值且不是 null。
- 比较方式：对于基本数据类型来说，== 比较的是值。对于包装数据类型来说，== 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 equals() 方法。

**为什么说是几乎所有对象实例都存在于堆中呢？** 

这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存

⚠️ 注意：基本数据类型存放在栈中是一个常见的误区！ 基本数据类型的成员变量如果没有被 static 修饰的话（不建议这么使用，应该要使用基本数据类型对应的包装类型），就存放在堆中。
## 6.3、final 在 java 中有什么作用？
（1）用来修饰一个引用

- 如果引用为基本数据类型，则该引用为常量，该值无法修改；
- 如果引用为引用数据类型，比如对象、数组，则该对象、数组本身可以修改，但指向该对象或数组的地址的引用不能修改。
- 如果引用时类的成员变量，则必须当场赋值，否则编译会报错。
（2）用来修饰一个方法

- 当使用final修饰方法时，这个方法将成为最终方法，无法被子类重写。但是，该方法仍然可以被继承。

（3）用来修饰类

- 当用final修改类时，该类成为最终类，无法被继承。

     - 比如常用的String类就是最终类。

